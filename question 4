#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define MAX_BUFFER_SIZE 516 // Taille maximale d'un paquet TFTP

// Fonction pour envoyer un acquittement (ACK)
void sendACK(int socket, struct sockaddr_in* serverAddress, uint16_t blockNumber) {
    char ackPacket[4];
    ackPacket[0] = 0x00;
    ackPacket[1] = 0x04;
    ackPacket[2] = (blockNumber >> 8) & 0xFF; // octet de poids fort
    ackPacket[3] = blockNumber & 0xFF;        // octet de poids faible

    sendto(socket, ackPacket, sizeof(ackPacket), 0, (struct sockaddr*)serverAddress, sizeof(*serverAddress));
}

int main() {
    // ... (création du socket et configuration de l'adresse du serveur)

    // Variables pour la réception de données
    char dataPacket[MAX_BUFFER_SIZE];
    struct sockaddr_in serverAddress;
    socklen_t serverAddressSize = sizeof(serverAddress);

    // Boucle de réception des paquets de données
    uint16_t blockNumber = 1; // Commence à 1 pour le premier paquet
    while (1) {
        // Réception du paquet de données
        ssize_t bytesRead = recvfrom(clientSocket, dataPacket, sizeof(dataPacket), 0,
                                     (struct sockaddr*)&serverAddress, &serverAddressSize);
        if (bytesRead == -1) {
            perror("Erreur lors de la réception du paquet de données");
            close(clientSocket);
            exit(EXIT_FAILURE);
        }

        // Traitement des données reçues (bytesRead contient le nombre d'octets reçus)

        // Envoi de l'acquittement
        sendACK(clientSocket, &serverAddress, blockNumber);

        // Si le paquet était le dernier, terminer la boucle
        if (bytesRead < MAX_BUFFER_SIZE) {
            break;
        }

        // Incrémentation du numéro de bloc pour le prochain acquittement
        blockNumber++;
    }

    // Fermeture du socket
    close(clientSocket);

    return 0;
}
